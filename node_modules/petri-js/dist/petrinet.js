'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _redux = require('redux');

var _reduxUndo = require('redux-undo');

var _reduxLogger = require('redux-logger');

var _d = require('d3');

var d3 = _interopRequireWildcard(_d);

var _actions = require('./actions');

var actions = _interopRequireWildcard(_actions);

var _reducers = require('./reducers');

var _reducers2 = _interopRequireDefault(_reducers);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// MARK: Some constants.

var TRANSITION_SIDE = 30;
var PLACE_RADIUS = Math.sqrt(TRANSITION_SIDE * TRANSITION_SIDE / 2);

// MARK: Default semantics.

function defaultIsFireable(t, marking) {
  console.log('custom editing---default-');
  return Object.keys(t.preconditions).every(function (p) {
    return marking[p] >= t.preconditions[p];
  });
}

function defaultFire(t, marking) {
  console.log('custom editing----');
  var pre = t.preconditions;
  var post = t.postconditions;
  var nextMarking = {};

  for (var p in marking) {
    if (!marking.hasOwnProperty(p)) {
      throw new Error('\'' + p + '\' is precondition of \'' + t.name + '\' but doesn\'t appear in marking \'' + marking + '\'.');
    }

    nextMarking[p] = (marking[p] || 0) - (pre[p] || 0) + (post[p] || 0);

    if (nextMarking[p] < 0) {
      throw new Error('\'' + t.name + '\' is not fireable');
    }
  }

  return nextMarking;
}

// MARK: The PetriNet class.

var PetriNet = function () {
  function PetriNet(element, model) {
    var _this = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : { fireSemantics: {}, enableLogging: false };

    _classCallCheck(this, PetriNet);

    this.svg = d3.select(element);
    var width = this.svg.node().getBoundingClientRect().width;
    var height = this.svg.node().getBoundingClientRect().height;

    // Handle default options.
    var customFireSemantics = options.fireSemantics || {};
    this.fireSemantics = {
      isFireable: customFireSemantics.isFireable || defaultIsFireable,
      fire: customFireSemantics.fire || defaultFire,
      chooseBinding: customFireSemantics.chooseBinding || null

      // Build the arrow en marker. Note that arrows are drawn like that: ``-->-``. Hence we should draw
      // their source and target nodes over them, so as to hide the exceeding parts.
    };this.svg.append('svg:defs').selectAll('marker').data(['end']).enter().append('svg:marker').attr('id', String).attr('refX', TRANSITION_SIDE).attr('refY', 4).attr('markerWidth', 12).attr('markerHeight', 12).attr('orient', 'auto').append('svg:path').attr('d', 'M0,0 L0,8 L8,4 z');

    this.arcsGroup = this.svg.append('g').attr('class', 'arcs');
    this.nodesGroup = this.svg.append('g').attr('class', 'nodes');

    // Create the force simulation.
    this.simulation = d3.forceSimulation().force('link', d3.forceLink().id(function (d) {
      return d.id;
    }).distance(50)).force('charge', d3.forceManyBody()).force('center', d3.forceCenter(width / 2, height / 2)).force('collide', d3.forceCollide().radius(TRANSITION_SIDE * 2)).on('tick', function () {
      _this.nodesGroup.selectAll('g').attr('transform', function (d) {
        return 'translate(' + d.x + ', ' + d.y + ')';
      });
      _this.arcsGroup.selectAll('g line').attr('x1', function (d) {
        return d.source.x;
      }).attr('y1', function (d) {
        return d.source.y;
      }).attr('x2', function (d) {
        return d.target.x;
      }).attr('y2', function (d) {
        return d.target.y;
      });
      _this.arcsGroup.selectAll('g text').attr('x', function (d) {
        return (d.source.x + d.target.x) / 2;
      }).attr('y', function (d) {
        return (d.source.y + d.target.y) / 2;
      });
    });

    // Create the redux store.
    this.store = options.enableLogging ? this.store = (0, _redux.createStore)(_reducers2.default, (0, _redux.applyMiddleware)((0, _reduxLogger.createLogger)({ collapsed: true }))) : this.store = (0, _redux.createStore)(_reducers2.default);
    this.store.subscribe(this.render.bind(this));
    this.store.dispatch(actions.init(model));
    this.store.dispatch(_reduxUndo.ActionCreators.clearHistory());
  }

  _createClass(PetriNet, [{
    key: 'handleDragStart',
    value: function handleDragStart(d) {
      if (!d3.event.active) {
        this.simulation.alphaTarget(0.3).restart();
      }
      d.fx = d.x;
      d.fy = d.y;
    }
  }, {
    key: 'handleDrag',
    value: function handleDrag(d) {
      d.fx = d3.event.x;
      d.fy = d3.event.y;
    }
  }, {
    key: 'handleDragEnd',
    value: function handleDragEnd(d) {
      if (!d3.event.active) {
        this.simulation.alphaTarget(0);
      }
      d.fx = null;
      d.fy = null;
    }
  }, {
    key: 'marking',
    value: function marking() {
      return this.store.getState().marking.present;
    }
  }, {
    key: 'sequence',
    value: function sequence() {
      return this.store.getState().sequence.present;
    }
  }, {
    key: 'fire',
    value: function fire(transition) {
      var marking = this.store.getState().marking.present;
      var binding = this.fireSemantics.chooseBinding !== null ? this.fireSemantics.chooseBinding(transition, marking) : null;
      this.store.dispatch(actions.fireTransition(transition, marking, binding, this.fireSemantics.fire));
    }
  }, {
    key: 'undo',
    value: function undo() {
      this.store.dispatch(_reduxUndo.ActionCreators.undo());
    }
  }, {
    key: 'redo',
    value: function redo() {
      this.store.dispatch(_reduxUndo.ActionCreators.redo());
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var model = this.store.getState().model;
      var marking = this.store.getState().marking.present;

      // Adapt places and transitions data to d3. The goal is to create an array that contains all
      // vertices and another that contains all egdes, so that it'll be easier to handle them in the
      // force simulation later on.

      // vertices: [(id: String, type: String)]
      var vertices = model.places.map(function (place) {
        return { id: place, type: 'place' };
      }).concat(model.transitions.map(function (transition) {
        return _extends({}, transition, {
          id: transition.name,
          type: 'transition',
          fire: function fire() {
            return _this2.fire(transition);
          }
        });
      }));

      // edges: [(source: String, target: String, label: Model.Transition.Label)]
      var edges = model.transitions.map(function (transition) {
        var preconditions = Object.keys(transition.preconditions).map(function (place) {
          return {
            id: place + transition.name,
            source: place,
            target: transition.name,
            label: transition.preconditions[place]
          };
        });
        var postconditions = Object.keys(transition.postconditions).map(function (place) {
          return {
            id: transition.name + place,
            source: transition.name,
            target: place,
            label: transition.postconditions[place]
          };
        });
        return preconditions.concat(postconditions);
      }).reduce(function (partialResult, e) {
        return partialResult.concat(e);
      });

      // Note that because d3 will mutate the data objects we'll bind to the vertices, we can't bind
      // the updated data as is. Instead, we should mutate the already bound objetcs, so that we can
      // preserve the positions and relations that were computed by the previous simulation run.
      var updatedVertices = this.nodesGroup.selectAll('g').data();

      var _loop = function _loop(vertex) {
        var prev = updatedVertices.find(function (v) {
          return v.id == vertex.id;
        });
        if (typeof prev !== 'undefined') {
          for (var prop in vertex) {
            prev[prop] = vertex[prop];
          }
        } else {
          updatedVertices.push(vertex);
        }
      };

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = vertices[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var vertex = _step.value;

          _loop(vertex);
        }

        // Draw new places and new transitions.
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      var arcs = this.arcsGroup.selectAll('g').data(edges, function (d) {
        return d.id;
      });
      arcs.exit().remove();

      var arcsEnter = arcs.enter().append('g').attr('id', function (edge) {
        return edge.id;
      });
      arcsEnter.append('line').attr('stroke', 'black').attr('stroke-width', 1).attr('marker-end', 'url(#end)');
      arcsEnter.filter(function (edge) {
        return edge.label != '1';
      }).append('text').text(function (edge) {
        return edge.label;
      });

      arcs = arcsEnter.merge(arcs);

      var nodes = this.nodesGroup.selectAll('g').data(updatedVertices, function (d) {
        return d.id;
      });

      var nodesEnter = nodes.enter().append('g').attr('id', function (vertex) {
        return vertex.id;
      }).attr('class', function (vertex) {
        return vertex.type;
      }).call(d3.drag().on('start', this.handleDragStart.bind(this)).on('drag', this.handleDrag.bind(this)).on('end', this.handleDragEnd.bind(this)));

      var places = nodesEnter.filter('.place');
      places.append('circle').attr('r', function () {
        return PLACE_RADIUS;
      }).attr('fill', 'rgb(255, 248, 220)').attr('stroke', 'rgb(224, 220, 191)').attr('stroke-width', '3px');
      places.append('text').attr('class', 'marking').attr('text-anchor', 'middle').attr('alignment-baseline', 'central');
      places.append('text').attr('text-anchor', 'left').attr('alignment-baseline', 'central').attr('dx', PLACE_RADIUS * 1.25).text(function (place) {
        return place.id;
      });

      var transitions = nodesEnter.filter('.transition').attr('cursor', 'pointer');
      transitions.append('circle').attr('r', PLACE_RADIUS).attr('fill', 'white');
      transitions.append('rect').attr('width', TRANSITION_SIDE).attr('height', TRANSITION_SIDE).attr('x', -TRANSITION_SIDE / 2).attr('y', -TRANSITION_SIDE / 2).attr('fill', 'rgb(220, 227, 255)').attr('stroke', 'rgb(169, 186, 255)').attr('stroke-width', 3);
      transitions.append('text').attr('text-anchor', 'middle').attr('alignment-baseline', 'central').text(function (transition) {
        return transition.id;
      });
      transitions.on('click', function (t) {
        return t.fire();
      });

      nodes = nodesEnter.merge(nodes);

      // Update place markings and transition states.
      nodes.filter('.place').select('.marking').text(function (p) {
        return marking[p.id];
      });
      nodes.filter('.transition').classed('fireable', function (t) {
        return _this2.fireSemantics.isFireable(t, marking);
      });

      // Run the force simulation to space out places and transitions.
      this.simulation.nodes(updatedVertices).force('link').links(edges);
    }
  }]);

  return PetriNet;
}();

exports.default = PetriNet;